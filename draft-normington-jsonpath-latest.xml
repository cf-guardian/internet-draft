<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE rfc SYSTEM "rfc2629-xhtml.ent">
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<rfc
      xmlns:xi="http://www.w3.org/2001/XInclude"
      category="std"
      consensus="true"
      docName="draft-normington-jsonpath-latest"
      ipr="trust200902"
      obsoletes=""
      updates=""
      submissionType="IETF"
      xml:lang="en"
      tocInclude="true"
      tocDepth="4"
      symRefs="true"
      sortRefs="true"
      version="3">
  <!-- xml2rfc v2v3 conversion 2.38.1 -->
  <!-- category values: std, bcp, info, exp, and historic
    ipr values: trust200902, noModificationTrust200902, noDerivativesTrust200902,
       or pre5378Trust200902
    you can add the attributes updates="NNNN" and obsoletes="NNNN" 
    they will automatically be output with "(if approved)" -->

 <!-- ***** FRONT MATTER ***** -->

 <front>
    <!-- The abbreviated title is used in the page header - it is only necessary if the 
        full title is longer than 39 characters -->

   <title>JavaScript Object Notation (JSON) Path</title>
    <seriesInfo name="Internet-Draft" value="draft-normington-jsonpath-00"/>
    <!-- add 'role="editor"' below for the editors if appropriate -->

   <!-- Another author who claims to be an editor -->

    <author fullname="Glyn Normington" initials="G" role="editor" surname="Normington">
      <organization>VMware, Inc.</organization>
      <address>
        <postal>
          <street/>
          <city>Winchester</city>
          <region/>
          <code/>
          <country>UK</country>
        </postal>
        <phone/>
        <email>glyn.normington@gmail.com</email>
     </address>
    </author>
    <date year="2020"/>
    <!-- If the month and year are both specified and are the current ones, xml2rfc will fill 
        in the current day for you. If only the current year is specified, xml2rfc will fill 
	 in the current day and month for you. If the year is not the current one, it is 
	 necessary to specify at least a month (xml2rfc assumes day="1" if not specified for the 
	 purpose of calculating the expiry date).  With drafts it is normally sufficient to 
	 specify just the year. -->

   <!-- Meta-data Declarations -->

   <area>General</area>
    <workgroup>Internet Engineering Task Force</workgroup>
    <!-- WG name at the upperleft corner of the doc,
        IETF is fine for individual submissions.  
	 If this element is not present, the default is "Network Working Group",
        which is used by the RFC Editor as a nod to the history of the IETF. -->

   <keyword>JSON</keyword>
   <keyword>JSONPath</keyword>
    <!-- Keywords will be incorporated into HTML output
        files in a meta tag but they have no effect on text or nroff
        output. If you submit your draft to the RFC Editor, the
        keywords will be used for the search engine. -->

   <abstract>
      <t>JSON Path defines a string syntax for identifying values
   within a JavaScript Object Notation (JSON) document.</t>
    </abstract>
    <note>
      <t><strong>This document is a work in progress and has not yet been published as an Internet Draft.</strong></t>
    </note>
  </front>

   <!-- ***** MIDDLE MATTER ***** -->

  <middle>
    <section numbered="true" toc="default">
      <name>Introduction</name>
      <!-- move the following to an Acknowledgements appendix and write a proper introduction -->
      <t>JSON Path, or rather JSONPath, was introduced by Stefan Goessner as a simple form of XPath for JSON.
         See his original article <xref target="Goessner" format="default">Goessner</xref>.
      </t>
      <t>JSON is defined by <xref target="RFC8259" format="default">RFC&nbsp;8259</xref>.
      </t>

      <section numbered="true" toc="default">
        <name>Requirements Language</name>
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
       "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
       document are to be interpreted as described in <xref target="RFC2119" format="default">RFC&nbsp;2119</xref>.</t>
      </section>

      <section numbered="true" toc="default">
        <name>ABNF Syntax</name>
        <t>The syntax in this document conforms to ABNF as defined by <xref target="RFC5234" format="default">RFC&nbsp;5234</xref>.
        </t>
        <t>ABNF terminal values in this document define Unicode code points rather than their UTF-8 encoding.
           For example, the Unicode PLACE OF INTEREST SIGN (U+2318) would be defined in ABNF as <tt>%x2318</tt>.
        </t>
      </section>
    </section>
   <section numbered="true" toc="default">
      <name>JSON Path Syntax and Semantics</name>
         <section numbered="true" toc="default">
            <name>Overview</name>
            <t>A JSON Path is a string which matches zero or more nodes of any JSON document. A valid JSON Path conforms to the ABNF syntax defined by this document.
            </t>
            <t>A JSON Path MUST be encoded using UTF-8. To parse a JSON Path according to the grammar in this document, its UTF-8 form SHOULD first be decoded into Unicode code points as described
               in <xref target="RFC3629" format="default">RFC&nbsp;3629</xref>.
            </t>
         </section>
         <section numbered="true" toc="default">
            <name>Terminology</name>
            <t>A JSON document is logically a tree of nodes with the document as the root node of the tree.
            </t>
            <t>Each node holds a JSON value (as defined by <xref target="RFC8259" format="default">RFC&nbsp;8259</xref>) of one of the types object, array, number, string, or one
               of the literals <tt>true</tt>, <tt>false</tt>, or <tt>null</tt>. The type of the JSON value held by a node is sometimes referred to as the type of the node.
            </t>
            <t>The descendants of a node are taken to include the node itself and the descendants of any children of the node.
            </t>
         </section>
         <section numbered="true" toc="default">
            <name>Implementation</name>
            <t>An implementation of this specification, from now on referred to simply as "an implementation", SHOULD takes two inputs, a JSON Path and a JSON document, and produce
               a possibly empty list of nodes of the JSON document which match the JSON Path or an error (but not both).
            </t>
            <t>If there is no matching node and no error has occurred, an implementation MUST return an empty list of nodes.
            </t>
            <t>Syntax errors in the JSON Path SHOULD be detected before matching is attempted since they do not depend on the JSON document.
               Therefore, an implementation SHOULD take a JSON Path and produce an optional syntax error and then,
               if and only if an error was not produced, SHOULD take a JSON document and produce a list of matches or an error (but not both).
            </t>
            <t>Alternatively, an implementation MAY take a JSON Path and a JSON document and produce a list of matches or an optional error (but not both).
            </t>
            <t>For any implementation, if a syntactically invalid JSON Path is provided, the implementation MUST return an error.
            </t>
            <t>If a syntactially invalid JSON document is provided, any implementation SHOULD return an error.
            </t>
         </section>
         <section numbered="true" toc="default">
            <name>Syntax</name>
            <t>Syntactically, a JSON Path consists of a root selector (<tt>$</tt>), which selects the root node of a JSON document, followed by a possibly empty sequence of <em>matchers</em>.
            </t>
            <sourcecode type="abnf">
json-path = root-selector *matcher
root-selector = %x24               ; $ selects document root node
            </sourcecode>
            <t>The syntax and semantics of each matcher is defined below.
            </t>
         </section>
         <section numbered="true" toc="default">
            <name>Semantics</name>
            <t>The root selector <tt>$</tt> not only selects the root node of the input document, but it also produces as output a list consisting of one node: the input document.
            </t>
            <t>A matcher may match a node and, if it matches, may then select zero or more descendants of the node for further processing.
               But there's more to it than this: each matcher acts on a list of nodes and produces a list of nodes, as follows.
            </t>
            <t>After the root selector, the remainder of the JSON Path is processed by passing lists of nodes from one matcher to the next ending up with a list of nodes which is the result of
               matching the JSON Path to the input JSON document.
            </t>
            <t>Each matcher acts on its input list of nodes as follows. For each node in the list, the matcher may or may not match the node. If the matcher
               matches the node, it selects zero or more descendants of the node.
               The output list of nodes of a matcher is the concatenation of the lists of selected descendents for each input node. 
            </t>
            <t>A specific, non-normative example will make this clearer. Suppose the input document is: <tt>{"a":[{"b":0},{"b":1},{"b":2}]}</tt>. As we will see later, the JSON Path
               <tt>$.a[*].b</tt> selects the following list of nodes: <tt>0</tt>, <tt>1</tt>, <tt>2</tt>. Let's walk through this in detail.
            </t>
            <t>The JSON Path consists of <tt>$</tt> followed by three matchers: <tt>.a</tt>, <tt>[*]</tt>, and <tt>.b</tt>.
            </t>
            <t>Firstly, <tt>$</tt> matches the input document and selects the root node which is the input document. So the result is a list consisting of just the root node.
            </t>
            <t>Next, <tt>.a</tt> matches any input node of type object and selects any value of the input node corresponding to the key <tt>"a"</tt>.
               The result is again a list of one node: <tt>[{"b":0},{"b":1},{"b":2}]</tt>.
            </t>
            <t>Next, <tt>[*]</tt> matches any input node which is an array and selects all the elements of the input node.
               The result is a list of three nodes: <tt>{"b":0}</tt>, <tt>{"b":1}</tt>, and <tt>{"b":2}</tt>. 
            </t>
            <t>Finally, <tt>.b</tt> matches any input node of type object and selects any value of the input node corresponding to the key <tt>"b"</tt>.
               The result is the concatenation of three lists each of length one containing <tt>0</tt>, <tt>1</tt>, <tt>2</tt>, respectively.
            </t>
            <t>As a consequence of this approach, if any of the matchers matches no nodes, then the whole JSON Path matches no nodes.
            </t>
            <t>In what follows, the semantics of each matcher are defined for each type of node.
            </t>
         </section>       
         <section numbered="true" toc="default">
            <name>Matchers</name>
            <section numbered="true" toc="default">
               <name>Dot Child Matcher</name>
               <section numbered="false" toc="exclude">
                  <name>Syntax</name>
                  <t>A dot child matcher has a key known as a dot child name or a single asterisk (<tt>*</tt>).
                  </t>
                  <t>A dot child name corresponds to a key in a JSON object, without the surrounding double quotes (<tt>"</tt>).
                  </t>
                  <sourcecode type="abnf">
matcher = dot-child             ; see below for alternatives
dot-child = %x2E dot-child-name / ; .&lt;dot-child-name&gt;
            %x2E %x2A             ; .*
dot-child-name = TBD
                  </sourcecode>
                  <!-- TODO: define dot-child-name using an identifier like syntax. See https://github.com/cburgmer/json-path-comparison/issues/42 -->
                  <t>More general child names, such as the empty string, are supported by "Union Child" (<xref target="unionchild" format="default"/>).
                  </t>
               </section>       
               <section numbered="false" toc="exclude">
                  <name>Semantics</name>
                  <t>A dot child name which is not a single asterisk (<tt>*</tt>) matches any node which is an object having a key equal to the dot child name
                  and selects the value corresponding to that key.
                  It does not match a node which is not an object.
                  </t>
                  <t>A dot child name consisting of a single asterisk is a wild card. It matches any node which is an object and selects all the values of the object.
                     It also matches any node which is an array and selects all the elements of the array. It does not match a number, string, or literal node.
                  </t>
               </section>       
            </section>       
            <section numbered="true" toc="default">
               <name>Union Matcher</name>
               <section numbered="true" toc="default">
                  <name>Syntax</name>
                  <t>A union matcher consists of one or more union elements.
                  </t>
                  <sourcecode type="abnf">
matcher =/ union
union = %x5B ws union-elements ws %x5D ; [...]
ws = *%x20                             ; zero or more spaces
union-elements = union-element /
                 union-element ws %x2C ws union-elements
                                       ; ,-separated list
                  </sourcecode>
               </section>       
               <section numbered="true" toc="default">
                  <name>Semantics</name>
                  <t>A union matches any node which is matched by at least one of the union elements and selects the concatenation of the
                     lists (in the order of the matchers) of descendants selected by the union elements.
                  </t>
               </section>
               <section numbered="true" toc="default" anchor="unionchild">
                  <name>Union Child</name>
                  <section numbered="false" toc="exclude">
                     <name>Syntax</name>
                     <t>A union child is a union element consisting of a quoted string.
                     </t>
                     <sourcecode type="abnf">
union-element = union-child ; see below for more alternatives
union-child = %x27 *single-quoted %x27 / ; 'string'
              %x22 *double-quoted %x22   ; "string"

single-quoted = %x5C %x27 / ; \' (escaped single quote)
                %x5C %x5C / ; \\ (escaped reverse solidus)
                %x00-26 / %x28-5B %x5D-D7FF / %xE000-10FFFF
                            ; any Unicode code point except ' or \

double-quoted = %x5C 5x22 / ; \" (escaped double quote)
                %x5C 5x5C / ; \\ (escaped reverse solidus)
                %x00-21 / %x23-5B / %x5D-D7FF / %xE000-10FFFF
                            ; any Unicode code point except " or \
                     </sourcecode>
                     <t>Note: the syntax does not allow any character other than a quote or reverse solidus to be escaped.
                     </t>
                  </section>       
                  <section numbered="false" toc="exclude">
                     <name>Semantics</name>
                     <t>If the union child is a quoted string, the string must first have the surrounding quotes removed and then be unescaped
                        as describe below.
                        The union child matches any node which is an object having a key equal to the unescaped value of the union child string
                        and selects the value corresponding to that key.
                        It does not match a node which is not an object.
                     </t>
                     <t>After the surrounding quotes have been removed, a string is unescaped by replacing each escaped quote by the corresponding
                        quote and replacing each escaped reverse solidus by a reverse solidus.
                     </t>
                  </section>       
               </section>             
               <section numbered="true" toc="default">
                  <name>Array Index</name>
                  <section numbered="false" toc="exclude">
                     <name>Syntax</name>
                     <t>An array index is a union element consisting of an integer (in base 10).
                     </t>
                     <sourcecode type="abnf">
union-element =/ integer
integer = [%x2D] (%x30 / (%x31-39 *%x30-39))
                            ; optional - followed by 0 or
                            ; sequence of digits with no leading zero
                     </sourcecode>
                     <t>Note: the syntax does not allow integers with leading zeros such as <tt>01</tt> and <tt>-01</tt>.
                     </t>
                  </section>       
                  <section numbered="false" toc="exclude">
                     <name>Semantics</name>
                     <t>An array index matches any node which is an array and selects any element of the array indexed by the integer index.
                        It does not match a node which is not an array.
                     </t>
                     <t>A non-negative index <tt>i</tt> selects an element of an array of length <tt>len</tt> if and only if <tt>0 &lt;= i &lt; len</tt>.
                        The index <tt>0</tt> selects the first element of a non-empty array and, providing <tt>i &lt; len - 1</tt>, index <tt>i + 1</tt>
                        selects the element immedately after (in array order) the element selected by index <tt>i</tt>.
                     </t>
                     <t>A negative index <tt>j</tt> selects an element of an array of length <tt>len</tt> if and only if <tt>0 &lt;= j + len &lt; len</tt>,
                        in which case it selects the same element as selected by the non-negative index <tt>j + len</tt>.
                     </t>
                  </section>       
               </section>             
               <section numbered="true" toc="default">
                  <name>Array Slice</name>
                  <section numbered="false" toc="exclude">
                     <name>Syntax</name>
                     <t>An array slice is a union element consisting of two or three integers (in base 10 and which may be omitted) separated by colons.
                     </t>
                     <sourcecode type="abnf">
union-element =/ [ integer ] ws %x3A ws [ integer ]
                   [ ws %x3A ws non-zero-integer ]
                            ; start:end or start:end:step
non-zero-integer = [%x2D] %x31-39 *%x30-39
                            ; optional - followed by
                            ; sequence of digits with no leading zero
                    </sourcecode>
                    <t>Note: the third integer, if present, MUST be non-zero.
                    </t>
                  </section>       
                  <section numbered="false" toc="exclude">
                     <name>Semantics</name>
                     <t>An array slice matches any node which is an array and selects any elements of the array included in the slice, as defined below.
                        It does not match a node which is not an array.
                     </t>
                     <t>The elements selected by a slice depend on whether the step value is positive or negative, as follows. If the step value is
                        omitted, it defaults to <tt>1</tt>.
                     </t>
                     <t>For positive integer <tt>step</tt> and integers <tt>start</tt> and <tt>end</tt>, the array slice
                        <tt>start:end:step</tt> selects any elements with indices starting with <tt>start</tt> and increasing repeatedly
                        by <tt>step</tt> while the resultant index is less than <tt>end</tt>. The index <tt>0</tt> corresponds to the
                        first element of the array. Any index less than zero or greater than or equal to the length of the array does not
                        select an element. The indices of the slice are the same as the values of i iterated over by this <tt>for</tt> loop in C:
                     </t>
                     <sourcecode type="c">
for (i = start; i &lt; end; i = i + step) {
  ...
}
                     </sourcecode>
                     <t>Note: if <tt>start >= end</tt>, the slice is empty and no elements are selected.
                     </t>
                     <t>When <tt>step></tt> is positive, the default value of <tt>start</tt> is <tt>0</tt> and the default value of <tt>end</tt> is the length of the array.
                     </t>
                     <t>If <tt>start</tt> or <tt>end</tt> are negative, this is simply a shorthand way of indexing from the end of the array.
                        If <tt>start</tt> is negative, the starting index is <tt>len + start</tt> where <tt>len</tt> is the length of the array
                        being sliced. Similarly for <tt>end</tt>.
                     </t>
                     <t>For negative integer <tt>step</tt> and integers <tt>start</tt> and <tt>end</tt>, the array slice
                        <tt>start:end:step</tt> selects any elements with indices starting with <tt>start</tt> and decreasing repeatedly
                        by <tt>step</tt> while the resultant index is greater than <tt>end</tt>. The index <tt>0</tt> corresponds to the
                        first element of the array. Any index less than zero or greater than or equal to the length of the array does not
                        select an element. The indices of the slice are the same as the values of i iterated over by this <tt>for</tt> loop in C:
                     </t>
                     <sourcecode type="c">
for (i = start; i &gt; end; i = i + step) {
  ...
}
                     </sourcecode>
                     <t>Note: if <tt>start &lt;= end</tt>, the slice is empty and no elements are selected.
                     </t>
                     <t>When <tt>step</tt> is negative, the default value of <tt>start</tt> is <tt>len - 1</tt> and the default value of <tt>end</tt> is <tt>-1</tt>
                     (literally, not in the earlier sense of a shorthand for <tt>len - 1</tt>).
                     </t>
                     <t>The meaning of negative <tt>start</tt> or <tt>end</tt> is the same as when <tt>step</tt> is positive.
                     </t>
                     <!--
Let's start by agreeing some basic behaviour of the array slice[start;end;step] for non-negative start, end, and step:

start is the inclusive starting point of the slice (with 0 meaning the first element of the array)
end is the exclusive end point, or "fence post" (see below), of the slice
step is the value we should add on each iteration, and must be non-zero to avoid an infinite loop (unless start >= end)
So, when step is positive, the indices of the slice are the same as the values of i iterated over by this for loop in C:

for (i = start; i < end; i = i + step) {
  ...
}
Notice that if start >= end, the slice is empty. Also, indices which are greater than or equal to the length of the array are discarded.

Some examples are in order:

[0:2:1] applied to [0,1,2] produces [0,1]
[1:1:1] applied to [0,1,2] produces []
[2:9:1] applied to [0,1,2] produces [2]
Default values
Any of the three values may be omitted:

start defaults to 0, so for example [:2:1] covers the first two elements of the array
end defaults to the length of the array, so for example [1::1] covers all except the first element of the array
step defaults to 1, so for example [1:3:] covers the second and third elements of the array
These defaults allow contractions such as [1:] and even [:] and [::].

Negative values
Now let's see how the notation can be extended to include negative values.

If start or end are negative, this is simply a shorthand way of indexing from the end of the array. If start is negative, the starting index is len+start where len is the length of the array being sliced. Similarly for end. This came from Göessner who defines $..book[-1:] to be the last book in the array. (Since 0 indexes the first element of an array, it might be tempting to make -0 index the last element of the array, were it not for the fact that -0 and 0 are equal, at least when treated as integers.)

But what does a negative step mean?

There seem to be three possible interpretations. The first two iterate in the direction start to end, so I've called them "forwards" interpretations. The third iterates in the direction end to start, so I've called it the "backwards" interpretation.

1. Forwards A
"forwards A" corresponds to the for loop:

for (i = start; i > end; i = i + step) {
  ...
}
The assumptions here are that start is still the inclusive starting point, end is still the exclusive end point, and to have any hope of a non-empty slice start > end.

So, for example, [2:0:-1] applied to [0,1,2] produces [2,1]. One problem with this interpretation is that there is no way to include the first value of the array in such a reverse slice. (correction: the way to do this is to omit the end value - see below.)

What should start and end default to? Perhaps length-1 and -1 (literally, not in the earlier sense of a shorthand for length-1). For example, with these defaults [::-1] enumerates the whole array backwards. Unfortunately, these defaults are not consistent with the defaults when step is positive.
                     -->
                  </section>       
               </section>             
            </section>       
         </section>       
   </section>
   <section anchor="IANA" numbered="true" toc="default">
      <name>IANA Considerations</name>
      <t>This memo includes no request to IANA.</t>
      <t>All drafts are required to have an IANA considerations section (see
     <xref target="RFC5226" format="default">Guidelines for Writing an IANA Considerations Section in RFCs</xref> for a guide). If the draft does not require IANA to do
     anything, the section contains an explicit statement that this is the
     case (as above). If there are no requirements for IANA, the section will
     be removed during conversion into an RFC by the RFC Editor.</t>
    </section>
    <section anchor="Security" numbered="true" toc="default">
      <name>Security Considerations</name>
      <t>This section gives security considerations, as required by <xref target="RFC3552" format="default">RFC&nbsp;3552</xref>.</t>
    </section>
   <section anchor="Alternatives" numbered="true" toc="default">
      <name>Alternatives</name>
      <t>An analogous standard, JSON Pointer, is provided by <xref target="RFC6901" format="default">RFC&nbsp;6901</xref>.</t>
    </section>
  </middle>

  <!--  *****BACK MATTER ***** -->

 <back>
   <references>
      <name>References</name>
      <references>
        <name>Normative References</name>
        <?rfc include="reference.RFC.2119.xml"?>
        <?rfc include="reference.RFC.3629.xml"?>
        <?rfc include="reference.RFC.5234.xml"?>
      </references>
      <references>
        <name>Informative References</name>
        <?rfc include="reference.RFC.3552.xml"?>
        <?rfc include="reference.RFC.5226.xml"?>
        <?rfc include="reference.RFC.6901.xml"?>
        <?rfc include="reference.RFC.8259.xml"?>
        <reference anchor="Goessner" target="https://goessner.net/articles/JsonPath/">
          <front>
            <title>JSONPath - XPath for JSON</title>
            <author>
              <organization>Stefan Gössner</organization>
            </author>
            <date year="2007" month="February"/>
          </front>
        </reference>
      </references>
    </references>
 </back>
</rfc>
